//! `highlite` — A configurable syntax-highlighting filter for terminal output.
//!
//! `highlite` reads text from a file or standard input and highlights matching
//! keywords or regular expressions according to a user-provided YAML
//! configuration file.
//!
//! ## Features
//!
//! - Highlight fixed keywords or regular expressions
//! - Per-rule and global case-insensitive matching
//! - Support for preset ANSI colors and 24-bit RGB colors
//! - Read from files or `stdin`
//! - Efficient multi-pattern matching using a single compiled regex
//!
//! ## Example
//!
//! ```bash
//! highlite --config rules.yaml --file file.txt
//!
//! cat file.txt | highlite --config rules.yaml
//! ```

use regex::Regex;
use std::fs;
use std::io::{BufRead, BufReader, BufWriter, IsTerminal, Write};

/// Types related to highlighting rules and color definitions.
///
/// This module defines the data structures used to describe how text
/// should be highlighted, including keywords, matching behavior, and
/// ANSI color output.
pub mod rules {
    use serde::Deserialize;

    /// A single highlighting rule.
    ///
    /// Each rule defines a keyword or pattern to match, along with the color
    /// used to render matched text.
    ///
    /// # Case sensitivity
    ///
    /// By default, matching is case-sensitive.
    /// If `ignore_case` is set to `true`, this rule will match text
    /// case-insensitively.
    ///
    /// Note:
    /// - If the CLI flag `--ignore-case` is provided, it overrides this
    ///   setting and forces all rules to be case-insensitive.
    ///
    /// # YAML
    /// Rules are typically loaded from a YAML configuration file.
    ///
    /// # Examples
    ///
    /// ```yaml
    /// rules:
    ///   - keyword: "ERROR"
    ///     color: { type: "Red" }
    ///     is_regex: false
    ///   - keyword: "//.*|/\\*.*\\*/"
    ///     is_regex: true
    ///     ignore_case: false
    ///     color: { r: 106, g: 153, b: 85 }
    /// ```
    #[derive(Debug, Clone, Deserialize)]
    pub struct Rule {
        pub keyword: String,
        pub color: Color,
        #[serde(default)]
        pub is_regex: bool,
        #[serde(default)]
        pub ignore_case: bool,
    }

    /// A predefined ANSI color.
    ///
    /// These colors correspond to standard 8-color ANSI escape sequences.
    #[derive(Debug, Copy, Clone, Deserialize)]
    #[serde(tag = "type", rename_all = "PascalCase", content = "value")]
    pub enum PresetColor {
        Red,
        Yellow,
        Blue,
        Green,
        Cyan,
        Magenta,
    }

    /// A color specification for highlighted text.
    ///
    /// Colors can be specified either as a predefined ANSI color
    /// or as a 24-bit RGB value.
    ///
    /// # Examples
    ///
    /// Using a preset ANSI color:
    ///
    /// ```yaml
    /// color: { type: Red }
    /// ```
    ///
    /// Using a 24-bit RGB value:
    /// ```yaml
    /// color: { r: 181, g: 206, b: 168 }
    /// ```
    #[derive(Debug, Copy, Clone, Deserialize)]
    #[serde(untagged)]
    pub enum Color {
        Preset(PresetColor),
        RGB { r: u8, g: u8, b: u8 },
    }

    impl Color {
        /// Converts this color into an ANSI escape sequence.
        ///
        /// The returned string enables the color when written to a terminal.
        /// Callers are responsible for resetting formatting (e.g. with `\x1b[0m`)
        /// after use.
        pub fn to_ansi(&self) -> String {
            match self {
                Color::Preset(p) => match p {
                    PresetColor::Red => "\x1b[31m".to_string(),
                    PresetColor::Yellow => "\x1b[33m".to_string(),
                    PresetColor::Blue => "\x1b[34m".to_string(),
                    PresetColor::Green => "\x1b[32m".to_string(),
                    PresetColor::Cyan => "\x1b[36m".to_string(),
                    PresetColor::Magenta => "\x1b[35m".to_string(),
                },
                Color::RGB { r, g, b } => format!("\x1b[38;2;{};{};{}m", r, g, b),
            }
        }
    }
}

/// Command-line argument parsing and configuration loading.
///
/// This module defines CLI options and functions for loading and resolving
/// highlighting rules from YAML configuration files, including recursive
/// `include` directives.
pub mod arg_parser {
    use crate::rules::Rule;
    use clap::Parser;
    use serde::Deserialize;
    use std::collections::HashSet;
    use std::fs;
    use std::path::{Path, PathBuf};

    /// Parsed command-line arguments.
    ///
    /// This structure is generated by `clap` and controls input source,
    /// configuration file location, and matching behavior.
    #[derive(Debug, Parser)]
    #[command(
        name = "highlite",
        about = "Highlight lines from stdin or a file",
        long_about = "Highlight lines from stdin or a file using a YAML configuration.\n\
                      Reads from stdin if no file is provided."
    )]
    pub struct CliArgs {
        /// Force to perform case-insensitive matching.
        /// This overrides `ignore_case` settings in the configuration file.
        #[arg(short, long)]
        pub ignore_case: bool,

        /// Path to the input file.
        /// If omitted, input is read from standard input.
        #[arg(short, long, help = "Path to the input file (defaults to stdin)")]
        pub file: Option<PathBuf>,

        /// Path to the YAML configuration file.
        /// This option is required.
        #[arg(short, long, required = true, help = "Path to the YAML config file (required)")]
        pub config: PathBuf,
    }

    /// Deserialized representation of a configuration file.
    ///
    /// A configuration file may include additional configuration files
    /// and/or define a list of highlighting rules.
    #[derive(Debug, Deserialize)]
    pub struct FileConfig {
        /// Paths to other configuration files to include.
        pub include: Option<Vec<String>>,

        /// Highlighting rules defined in this file.
        pub rules: Option<Vec<Rule>>,
    }

    /// Loads highlighting rules from a YAML configuration file.
    ///
    /// This function resolves `include` directives recursively and prevents
    /// duplicate loading of the same file.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use highlite::arg_parser::load_rules_from_file;
    ///
    /// let rules = load_rules_from_file("rules.yaml").unwrap();
    /// println!("Loaded {} rules", rules.len());
    /// ```
    ///
    /// # Errors
    ///
    /// Returns an error if a file cannot be read, parsed, or resolved.
    pub fn load_rules_from_file<P: AsRef<Path>>(path: P) -> anyhow::Result<Vec<Rule>> {
        let mut loaded_files = HashSet::new();
        load_rules_recursive(path.as_ref(), &mut loaded_files)
    }

    /// Recursively loads highlighting rules from a configuration file.
    ///
    /// This function parses the given YAML configuration file, resolves any
    /// `include` directives relative to the file's parent directory, and
    /// accumulates all discovered rules into a single list.
    ///
    /// To prevent infinite recursion and duplicate rule loading, each
    /// configuration file is canonicalized and tracked in the `loaded` set.
    /// Files that have already been processed are silently skipped.
    ///
    /// # Parameters
    ///
    /// * `path` - Path to the configuration file to load.
    /// * `loaded` - A set of canonicalized file paths that have already been
    ///   processed.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    ///
    /// * The file cannot be canonicalized
    /// * The file cannot be read
    /// * The YAML content cannot be parsed
    /// * An included file cannot be resolved or loaded
    fn load_rules_recursive(
        path: &Path,
        loaded: &mut HashSet<String>,
    ) -> anyhow::Result<Vec<Rule>> {
        let canonical_path = fs::canonicalize(path)?.to_string_lossy().to_string();

        if !loaded.insert(canonical_path) {
            return Ok(vec![]);
        }

        let text = fs::read_to_string(path)?;
        let file_config: FileConfig = serde_yml::from_str(&text)?;
        let mut all_rules = Vec::new();

        if let Some(includes) = file_config.include {
            let parent_dir = path.parent().unwrap_or_else(|| Path::new("."));
            for inc_path in includes {
                let full_path = parent_dir.join(inc_path);
                all_rules.append(&mut load_rules_recursive(&full_path, loaded)?);
            }
        }

        if let Some(current_rules) = file_config.rules {
            all_rules.extend(current_rules);
        }

        Ok(all_rules)
    }
}

/// High-performance text highlighting engine.
///
/// This module compiles all rules into a single regular expression and
/// efficiently renders matched text with ANSI color sequences.
///
/// # Examples
///
/// ```rust
/// use highlite::highlight::HighlightingEngine;
/// use highlite::rules::{Rule, Color, PresetColor};
///
/// let rules = vec![
///     Rule {
///         keyword: "error".into(),
///         color: Color::Preset(PresetColor::Red),
///         is_regex: false,
///         ignore_case: false,
///     },
/// ];
///
/// let engine = HighlightingEngine::new(&rules, true).unwrap();
///
/// let mut out = String::new();
/// engine.render_line("An error occurred\n", &mut out);
///
/// assert!(out.contains("\x1b[31m"));
/// ```
pub mod highlight {
    /// A compiled highlighting engine.
    ///
    /// Internally, all rules are combined into a single regular expression
    /// using named capture groups to efficiently determine which rule
    /// produced a match.
    pub struct HighlightingEngine {
        regex: crate::Regex,
        cap_to_color: Vec<usize>,
        ansi_colors: Vec<String>,
    }

    impl HighlightingEngine {
        /// Creates a new highlighting engine from a list of rules.
        /// with case-insensitive matching, regardless of their individual
        /// `ignore_case` settings.
        ///
        /// All rules are compiled into a single regular expression to minimize
        /// matching overhead.
        ///
        /// # Errors
        ///
        /// Returns an error if the combined regular expression fails to compile.
        pub fn new(
            rules: &[crate::rules::Rule],
            force_ignore_case: bool,
        ) -> anyhow::Result<Self> {
            use regex::RegexBuilder;

            let mut patterns = Vec::with_capacity(rules.len());
            let mut ansi_colors = Vec::with_capacity(rules.len());

            // 1. 构造每条规则的正则片段
            for (i, rule) in rules.iter().enumerate() {
                let base_pat = if rule.is_regex {
                    rule.keyword.clone()
                } else {
                    regex::escape(&rule.keyword)
                };

                let effective_ignore_case = force_ignore_case || rule.ignore_case;

                let pat = if effective_ignore_case {
                    // 使用 inline flag，做到 per-rule ignore_case
                    format!("(?i:{})", base_pat)
                } else {
                    base_pat
                };

                // 命名捕获组 r{i}
                patterns.push(format!("(?P<r{}>{})", i, pat));
                ansi_colors.push(rule.color.to_ansi());
            }

            // 2. 编译合并后的正则
            let regex = RegexBuilder::new(&patterns.join("|"))
                .multi_line(true)
                .dot_matches_new_line(false)
                .build()?;

            // 3. 建立 capture_index -> rule_index 的 O(1) 映射表
            //
            // cap_to_color[cap_idx] = rule_idx
            // 未使用的 capture index 用 usize::MAX 标记
            let mut cap_to_color = vec![usize::MAX; regex.captures_len()];

            for (cap_idx, name) in regex.capture_names().enumerate() {
                let Some(name) = name else { continue };
                let Some(idx) = name.strip_prefix('r') else { continue };
                let Ok(rule_idx) = idx.parse::<usize>() else { continue };

                cap_to_color[cap_idx] = rule_idx;
            }

            Ok(Self {
                regex,
                cap_to_color,
                ansi_colors,
            })
        }


        /// Renders a single line of input with highlighting applied.
        ///
        /// Matched segments are wrapped in ANSI color escape sequences.
        /// The output buffer is cleared before writing.
        ///
        /// # Examples
        ///
        /// This example is case-insensitive:
        /// ```rust
        /// # use highlite::highlight::HighlightingEngine;
        /// # use highlite::rules::{Rule, Color, PresetColor};
        /// let rules = vec![Rule {
        ///     keyword: "Ok".into(),
        ///     color: Color::Preset(PresetColor::Green),
        ///     is_regex: false,
        ///     ignore_case: true,
        /// }];
        ///
        /// let engine = HighlightingEngine::new(&rules, false).unwrap();
        /// let mut out = String::new();
        ///
        /// engine.render_line("Status: OK\n", &mut out);
        /// assert!(out.contains("\x1b[32mOK\x1b[0m"));
        /// ```
        ///
        /// But this is not:
        /// ```rust
        /// # use highlite::highlight::HighlightingEngine;
        /// # use highlite::rules::{Rule, Color, PresetColor};
        /// let rules = vec![Rule {
        ///     keyword: "Ok".into(),
        ///     color: Color::Preset(PresetColor::Green),
        ///     is_regex: false,
        ///     ignore_case: false,
        /// }];
        ///
        /// let engine = HighlightingEngine::new(&rules, false).unwrap();
        /// let mut out = String::new();
        ///
        /// engine.render_line("Status: OK\n", &mut out);
        /// assert!(!out.contains("\x1b[32mOK\x1b[0m"));
        /// ```
        pub fn render_line(&self, input: &str, output: &mut String) {
            output.clear();
            let mut last_match = 0;

            for caps in self.regex.captures_iter(input) {
                let m = caps.get(0).unwrap();

                output.push_str(&input[last_match..m.start()]);

                for (cap_idx, color_idx) in self.cap_to_color.iter().enumerate() {
                    if *color_idx == usize::MAX {
                        continue;
                    }
                    if let Some(sub) = caps.get(cap_idx) {
                        output.push_str(&self.ansi_colors[*color_idx]);
                        output.push_str(sub.as_str());
                        output.push_str("\x1b[0m");
                        break;
                    }
                }

                last_match = m.end();
            }
            // 写入剩余文本
            output.push_str(&input[last_match..]);
        }
    }
}
// --- Main Logic ---

/// Executes the main program logic using the provided CLI configuration.
///
/// This function loads the highlighting rules from the configuration file,
/// initializes the highlighting engine, and processes either the specified
/// input file or standard input.
///
/// If no input file is provided, the function reads from `stdin`.
/// When `stdin` is connected to a terminal, an informational message is printed
/// to stderr before waiting for input.
///
/// # Arguments
///
/// * `cli_args` - Parsed command-line arguments controlling input, configuration,
///   and matching behavior.
///
/// # Errors
///
/// Returns an error if:
///
/// * The configuration path is missing
/// * The configuration file cannot be read or parsed
/// * The input file cannot be opened
/// * An I/O error occurs while reading input or writing output
/// * The highlighting engine fails to initialize
///
/// # Examples
///
/// ```no_run
/// use highlite::{run, arg_parser::CliArgs};
///
/// let cli_args = CliArgs {
///     ignore_case: false,
///     file: Some(String::from("path/to/file").into()),
///     config: String::from("path/to/config.yaml").into(),
/// };
///
/// run(cli_args).unwrap();
/// ```
///
/// This function flushes all output before returning.
pub fn run(cli_args: arg_parser::CliArgs) -> anyhow::Result<()> {
    let config_path = cli_args.config;
    let raw_rules = arg_parser::load_rules_from_file(&config_path)?;

    // 1. 预编译引擎
    let engine = highlight::HighlightingEngine::new(&raw_rules, cli_args.ignore_case)?;

    // 2. 准备带缓冲的输出
    let stdout = std::io::stdout();
    let mut writer = BufWriter::new(stdout.lock());

    // 3. 处理输入
    if let Some(path) = cli_args.file {
        let f = fs::File::open(path)?;
        process_stream(BufReader::new(f), &engine, &mut writer)?;
    } else {
        if std::io::stdin().is_terminal() {
            eprintln!("(Info: Waiting for stdin... Press Ctrl+D to end)");
        }
        process_stream(BufReader::new(std::io::stdin()), &engine, &mut writer)?;
    }

    writer.flush()?;
    Ok(())
}

/// Processes a buffered input stream and writes highlighted output.
///
/// This function reads input line by line, applies syntax highlighting,
/// and writes the result to the provided output writer.
///
/// String buffers are reused across iterations to reduce allocations.
///
/// # Errors
///
/// Returns an error if an I/O error occurs while reading or writing.
fn process_stream<R: BufRead, W: Write>(
    mut reader: R,
    engine: &highlight::HighlightingEngine,
    writer: &mut W,
) -> anyhow::Result<()> {
    let mut line_buffer = String::new();
    let mut out_buffer = String::new();

    // 循环复用 String 内存，避免每行都分配内存
    while reader.read_line(&mut line_buffer)? > 0 {
        engine.render_line(&line_buffer, &mut out_buffer);
        writer.write_all(out_buffer.as_bytes())?;
        line_buffer.clear();
    }
    Ok(())
}


#[cfg(test)]
mod tests {
    use crate::highlight::HighlightingEngine;
    use crate::rules::{Color, PresetColor, Rule};

    #[test]
    fn rule_level_ignore_case_works() {
        let rules = vec![Rule {
            keyword: "error".into(),
            color: Color::Preset(PresetColor::Red),
            is_regex: false,
            ignore_case: true,
        }];

        let engine = HighlightingEngine::new(&rules, false).unwrap();
        let mut out = String::new();

        engine.render_line("ERROR\n", &mut out);
        assert!(out.contains("\x1b[31mERROR\x1b[0m"));
    }

    #[test]
    fn cli_ignore_case_overrides_rules() {
        let rules = vec![Rule {
            keyword: "error".into(),
            color: Color::Preset(PresetColor::Red),
            is_regex: false,
            ignore_case: false,
        }];

        let engine = HighlightingEngine::new(&rules, true).unwrap();
        let mut out = String::new();

        engine.render_line("ERROR\n", &mut out);
        assert!(out.contains("\x1b[31mERROR\x1b[0m"));
    }

    #[test]
    fn case_sensitive_rule_does_not_match() {
        let rules = vec![Rule {
            keyword: "error".into(),
            color: Color::Preset(PresetColor::Red),
            is_regex: false,
            ignore_case: false,
        }];

        let engine = HighlightingEngine::new(&rules, false).unwrap();
        let mut out = String::new();

        engine.render_line("ERROR\n", &mut out);
        assert!(!out.contains("\x1b[31m"));
    }
}
